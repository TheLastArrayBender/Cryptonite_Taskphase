# Answer

The provided questions seem to be related to different types of vulnerabilities and exploits in C programming, including buffer overflows and format string vulnerabilities. Let's address each problem individually.

## 1. Stonks

The problem statement mentions a format string vulnerability in the provided `vuln.c` file. Format string vulnerabilities occur when data read into a buffer is also used as a format string for a `printf` function or similar. In this case, the format string vulnerability is in the line `printf(user_buf);`.

The `printf` function interprets its arguments based on the format string. If an attacker can control the format string, they can read from or write to arbitrary memory locations, leading to information disclosure or remote code execution vulnerabilities. In this case, you can use format specifiers such as `%s`, `%ld`, or `%p` as input to the `scanf` function, causing `printf` to read from memory locations that it should not have access to.

To exploit this vulnerability, you can input a large number of `%p` format specifiers, causing `printf` to read and output data from the stack. You can then analyze the output to find the flag.

## 2. Babygame01

This problem involves a buffer overflow vulnerability. A buffer overflow occurs when more data is written to a buffer than it can hold, causing the extra data to overflow into adjacent memory locations. This can lead to arbitrary code execution if the overflowed data includes machine code and overwrites a return address on the stack.

In this case, the game's player position and flag status are stored in adjacent memory locations. You can exploit the lack of bounds checking in the `move_player` function to move the player to a location outside of the game board, causing the player's symbol to overflow into the memory location holding the flag status. By setting the player's symbol to a non-zero value, you can set the flag status to `true`, causing the `win` function to be called.

## 3. Buffer Overflow 0

This problem is another example of a buffer overflow vulnerability. The `gets` function is used to read input into a buffer without checking if the input is larger than the buffer, causing a buffer overflow if the input is too large.

In this case, you can exploit this vulnerability by providing an input string that is larger than the buffer. This causes the `gets` function to write past the end of the buffer, triggering a segmentation fault. The `sigsegv_handler` function is registered to handle segmentation faults and prints the flag when a segmentation fault occurs.

In all of these examples, the vulnerabilities can be prevented through secure coding practices, such as always checking the length of data before writing it to a buffer, using safe versions of functions that do not allow buffer overflows (e.g., `fgets` instead of `gets`), and not using user-controlled data as format strings [Source 0](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow), [Source 1](https://snyk.io/blog/buffer-overflow-attacks-in-c/), [Source 2](https://www.fortinet.com/resources/cyberglossary/buffer-overflow), [Source 6](https://www.csoonline.com/article/568835/what-is-a-buffer-overflow-and-how-hackers-exploit-these-vulnerabilities.html), [Source 9](https://resources.infosecinstitute.com/topics/secure-coding/how-to-mitigate-buffer-overflow-vulnerabilities/).
